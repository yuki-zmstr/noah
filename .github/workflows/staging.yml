name: Deploy to Staging

on:
  push:
    branches: [develop]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: noah-backend-staging
  ECS_SERVICE: NoahStagingStack-NoahBackendService
  ECS_CLUSTER: NoahStagingStack-NoahCluster
  AMPLIFY_APP_ID: d1234567890124 # Replace with actual staging Amplify App ID

jobs:
  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        working-directory: ./python-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: staging-${{ github.sha }}
        run: |
          # Build image with staging configuration
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --build-arg ENVIRONMENT=staging .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:staging-latest

          # Push image
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:staging-latest

      - name: Update staging ECS service
        run: |
          # Get current task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition ${{ env.ECS_SERVICE }} --query 'taskDefinition')

          # Update image URI in task definition
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:staging-${{ github.sha }}" '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')

          # Register new task definition
          NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEFINITION | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)

          # Update service
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --task-definition $NEW_TASK_DEF_ARN

          # Wait for deployment to complete
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}

      - name: Setup Node.js for frontend
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Get staging backend endpoint
        id: backend-endpoint
        run: |
          LOAD_BALANCER_DNS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --query 'services[0].loadBalancers[0].targetGroupArn' --output text | xargs -I {} aws elbv2 describe-target-groups --target-group-arns {} --query 'TargetGroups[0].LoadBalancerArns[0]' --output text | xargs -I {} aws elbv2 describe-load-balancers --load-balancer-arns {} --query 'LoadBalancers[0].DNSName' --output text)
          echo "dns=$LOAD_BALANCER_DNS" >> $GITHUB_OUTPUT

      - name: Build and deploy frontend to staging
        working-directory: ./frontend
        env:
          VITE_API_ENDPOINT: http://${{ steps.backend-endpoint.outputs.dns }}
          VITE_API_BASE_URL: http://${{ steps.backend-endpoint.outputs.dns }}/api
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID_STAGING }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.COGNITO_CLIENT_ID_STAGING }}
          VITE_COGNITO_IDENTITY_POOL_ID: ${{ secrets.COGNITO_IDENTITY_POOL_ID_STAGING }}
          VITE_ENVIRONMENT: staging
        run: |
          npm ci
          npm run build

          # Deploy to staging Amplify app
          cd dist
          zip -r ../staging-deployment.zip .
          cd ..

          # Upload and deploy
          aws s3 cp staging-deployment.zip "s3://amplify-staging-deployments/deployment-${{ github.sha }}.zip"

          DEPLOYMENT_ID=$(aws amplify start-deployment \
            --app-id ${{ env.AMPLIFY_APP_ID }} \
            --branch-name staging \
            --source-url "s3://amplify-staging-deployments/deployment-${{ github.sha }}.zip" \
            --query 'jobSummary.jobId' --output text)

          aws amplify wait job-complete --app-id ${{ env.AMPLIFY_APP_ID }} --branch-name staging --job-id $DEPLOYMENT_ID

  # Run staging tests
  staging-tests:
    name: Staging Environment Tests
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get staging URLs
        id: urls
        run: |
          # Get backend URL
          BACKEND_DNS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --query 'services[0].loadBalancers[0].targetGroupArn' --output text | xargs -I {} aws elbv2 describe-target-groups --target-group-arns {} --query 'TargetGroups[0].LoadBalancerArns[0]' --output text | xargs -I {} aws elbv2 describe-load-balancers --load-balancer-arns {} --query 'LoadBalancers[0].DNSName' --output text)
          echo "backend=http://$BACKEND_DNS" >> $GITHUB_OUTPUT

          # Get frontend URL
          FRONTEND_URL=$(aws amplify get-app --app-id ${{ env.AMPLIFY_APP_ID }} --query 'app.defaultDomain' --output text)
          echo "frontend=https://staging.$FRONTEND_URL" >> $GITHUB_OUTPUT

      - name: Setup Python for testing
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install test dependencies
        run: |
          pip install pytest httpx requests

      - name: Run staging smoke tests
        env:
          STAGING_BACKEND_URL: ${{ steps.urls.outputs.backend }}
          STAGING_FRONTEND_URL: ${{ steps.urls.outputs.frontend }}
        run: |
          # Create simple smoke test script
          cat > staging_tests.py << 'EOF'
          import requests
          import os
          import sys

          backend_url = os.environ['STAGING_BACKEND_URL']
          frontend_url = os.environ['STAGING_FRONTEND_URL']

          def test_backend_health():
              response = requests.get(f"{backend_url}/health")
              assert response.status_code == 200
              assert response.json()["status"] == "healthy"
              print("‚úÖ Backend health check passed")

          def test_backend_config():
              response = requests.get(f"{backend_url}/api/config")
              assert response.status_code == 200
              config = response.json()
              assert "app_name" in config
              print("‚úÖ Backend config endpoint passed")

          def test_frontend_accessibility():
              response = requests.get(frontend_url)
              assert response.status_code == 200
              print("‚úÖ Frontend accessibility passed")

          if __name__ == "__main__":
              try:
                  test_backend_health()
                  test_backend_config()
                  test_frontend_accessibility()
                  print("üéâ All staging tests passed!")
              except Exception as e:
                  print(f"‚ùå Staging test failed: {e}")
                  sys.exit(1)
          EOF

          python staging_tests.py

      - name: Run performance tests
        env:
          STAGING_BACKEND_URL: ${{ steps.urls.outputs.backend }}
        run: |
          # Simple performance test
          echo "Running performance tests..."

          # Test response times
          for i in {1..5}; do
            start_time=$(date +%s%N)
            curl -s "$STAGING_BACKEND_URL/health" > /dev/null
            end_time=$(date +%s%N)
            duration=$(( (end_time - start_time) / 1000000 ))
            echo "Health check $i: ${duration}ms"
            
            if [ $duration -gt 5000 ]; then
              echo "‚ùå Response time too slow: ${duration}ms"
              exit 1
            fi
          done

          echo "‚úÖ Performance tests passed"

      - name: Comment on PR with staging results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const body = `## üöÄ Staging Deployment Results

            **Status:** ‚úÖ Success
            **Backend URL:** ${{ steps.urls.outputs.backend }}
            **Frontend URL:** ${{ steps.urls.outputs.frontend }}
            **Commit:** ${{ github.sha }}

            ### Test Results
            - ‚úÖ Backend health check
            - ‚úÖ API configuration
            - ‚úÖ Frontend accessibility
            - ‚úÖ Performance tests

            The staging environment is ready for testing!
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Cleanup old staging deployments
  cleanup-staging:
    name: Cleanup Old Staging Deployments
    runs-on: ubuntu-latest
    needs: staging-tests
    if: always()
    environment: staging

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Cleanup old ECR images
        run: |
          # Keep only the last 10 staging images
          aws ecr list-images --repository-name ${{ env.ECR_REPOSITORY }} \
            --filter tagStatus=TAGGED \
            --query 'imageIds[?starts_with(imageTag, `staging-`)]' \
            --output json | \
          jq -r 'sort_by(.imageTag) | reverse | .[10:] | .[] | .imageDigest' | \
          while read digest; do
            if [ ! -z "$digest" ]; then
              aws ecr batch-delete-image --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageDigest=$digest
              echo "Deleted old staging image: $digest"
            fi
          done

      - name: Cleanup old S3 deployment packages
        run: |
          # Keep only the last 20 deployment packages
          aws s3 ls s3://amplify-staging-deployments/ --recursive | \
          sort -k1,2 | \
          head -n -20 | \
          awk '{print $4}' | \
          while read file; do
            if [ ! -z "$file" ]; then
              aws s3 rm "s3://amplify-staging-deployments/$file"
              echo "Deleted old deployment package: $file"
            fi
          done
