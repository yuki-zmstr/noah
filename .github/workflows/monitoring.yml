name: System Monitoring

on:
  schedule:
    # Run every 15 minutes
    - cron: "*/15 * * * *"
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-1

jobs:
  # Health monitoring
  health-check:
    name: Health Check Monitoring
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug AWS credentials presence and test auth
        run: |
          echo "Checking secrets presence..."
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then echo "AWS_ACCESS_KEY_ID is set"; else echo "AWS_ACCESS_KEY_ID is MISSING"; fi
          if [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then echo "AWS_SECRET_ACCESS_KEY is set"; else echo "AWS_SECRET_ACCESS_KEY is MISSING"; fi
          echo "Attempting to call STS to verify credentials..."
          # This will succeed if Configure AWS Credentials step provided usable credentials
          if aws sts get-caller-identity --output json; then
            echo "AWS STS succeeded"
          else
            echo "AWS STS failed ‚Äî credentials not usable"
            exit 1
          fi

      - name: Check production health
        id: prod-health
        run: |
          # Find the Noah cluster dynamically using CloudFormation
          STACK_NAME="NoahInfrastructureStack"

          # Get cluster name from CloudFormation stack
          ECS_CLUSTER=$(aws cloudformation describe-stack-resources \
            --stack-name $STACK_NAME \
            --query 'StackResources[?ResourceType==`AWS::ECS::Cluster`].PhysicalResourceId' \
            --output text 2>/dev/null || echo "")

          if [[ -z "$ECS_CLUSTER" || "$ECS_CLUSTER" == "None" ]]; then
            echo "status=not_deployed" >> $GITHUB_OUTPUT
            echo "endpoint=" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Production ECS cluster not found in CloudFormation stack"
            exit 0
          fi

          echo "Found ECS cluster: $ECS_CLUSTER"

          # Get service name from CloudFormation stack
          ECS_SERVICE=$(aws cloudformation describe-stack-resources \
            --stack-name $STACK_NAME \
            --query 'StackResources[?ResourceType==`AWS::ECS::Service`].PhysicalResourceId' \
            --output text 2>/dev/null || echo "")

          if [[ -z "$ECS_SERVICE" || "$ECS_SERVICE" == "None" ]]; then
            echo "status=not_deployed" >> $GITHUB_OUTPUT
            echo "endpoint=" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Production ECS service not found in CloudFormation stack"
            exit 0
          fi

          echo "Found ECS service: $ECS_SERVICE"

          # Get load balancer DNS
          TG_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].loadBalancers[0].targetGroupArn' --output text 2>/dev/null || echo "")

          if [[ -z "$TG_ARN" || "$TG_ARN" == "None" ]]; then
            echo "status=not_deployed" >> $GITHUB_OUTPUT
            echo "endpoint=" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Production load balancer not configured yet"
            exit 0
          fi

          LB_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TG_ARN --query 'TargetGroups[0].LoadBalancerArns[0]' --output text 2>/dev/null || echo "")

          if [[ -z "$LB_ARN" || "$LB_ARN" == "None" ]]; then
            echo "status=not_deployed" >> $GITHUB_OUTPUT
            echo "endpoint=" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Production load balancer not found"
            exit 0
          fi

          LB_DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns $LB_ARN --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")

          if [[ -z "$LB_DNS" || "$LB_DNS" == "None" ]]; then
            echo "status=not_deployed" >> $GITHUB_OUTPUT
            echo "endpoint=" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Production load balancer DNS not available"
            exit 0
          fi

          echo "endpoint=http://$LB_DNS" >> $GITHUB_OUTPUT

          # Test health endpoint
          if curl -f -m 10 "http://$LB_DNS/health"; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "‚úÖ Production health check passed"
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "‚ùå Production health check failed"
          fi

      - name: Check staging health
        id: staging-health
        run: |
          # Get staging load balancer DNS
          ECS_CLUSTER="NoahStagingStack-NoahCluster"
          ECS_SERVICE="NoahStagingStack-NoahBackendService"

          TG_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].loadBalancers[0].targetGroupArn' --output text 2>/dev/null || echo "")

          if [[ -n "$TG_ARN" && "$TG_ARN" != "None" ]]; then
            LB_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TG_ARN --query 'TargetGroups[0].LoadBalancerArns[0]' --output text)
            LB_DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns $LB_ARN --query 'LoadBalancers[0].DNSName' --output text)
            
            echo "endpoint=http://$LB_DNS" >> $GITHUB_OUTPUT
            
            # Test health endpoint
            if curl -f -m 10 "http://$LB_DNS/health"; then
              echo "status=healthy" >> $GITHUB_OUTPUT
              echo "‚úÖ Staging health check passed"
            else
              echo "status=unhealthy" >> $GITHUB_OUTPUT
              echo "‚ùå Staging health check failed"
            fi
          else
            echo "status=not_deployed" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Staging environment not deployed"
          fi

      - name: Create health alert if needed
        if: steps.prod-health.outputs.status == 'unhealthy'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `üö® Production Health Check Failed`;
            const body = `## Production Health Alert

            **Status:** ‚ùå Unhealthy
            **Endpoint:** ${{ steps.prod-health.outputs.endpoint }}
            **Timestamp:** ${new Date().toISOString()}
            **Check Type:** Automated monitoring

            ### Immediate Actions Required
            1. Check AWS ECS service status
            2. Review CloudWatch logs
            3. Verify load balancer configuration
            4. Consider triggering emergency rollback if needed

            ### Escalation
            - [ ] Notify on-call engineer
            - [ ] Check system metrics
            - [ ] Investigate root cause

            This alert was generated by automated monitoring.
            `;

            // Create issue for health alert
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['alert', 'health-check', 'production']
            });

            console.log(`Created health alert: ${issue.data.html_url}`);

  # Performance monitoring
  performance-check:
    name: Performance Monitoring
    runs-on: ubuntu-latest
    needs: health-check

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check CloudWatch metrics
        run: |
          # Get recent metrics from CloudWatch
          END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S)
          START_TIME=$(date -u -d '15 minutes ago' +%Y-%m-%dT%H:%M:%S)

          echo "Checking metrics from $START_TIME to $END_TIME"

          # Check CPU utilization
          CPU_METRICS=$(aws cloudwatch get-metric-statistics \
            --namespace AWS/ECS \
            --metric-name CPUUtilization \
            --dimensions Name=ServiceName,Value=NoahInfrastructureStack-NoahBackendService Name=ClusterName,Value=NoahInfrastructureStack-NoahCluster \
            --start-time $START_TIME \
            --end-time $END_TIME \
            --period 300 \
            --statistics Average,Maximum \
            --query 'Datapoints[0].Average' --output text 2>/dev/null || echo "0")

          # Check memory utilization
          MEMORY_METRICS=$(aws cloudwatch get-metric-statistics \
            --namespace AWS/ECS \
            --metric-name MemoryUtilization \
            --dimensions Name=ServiceName,Value=NoahInfrastructureStack-NoahBackendService Name=ClusterName,Value=NoahInfrastructureStack-NoahCluster \
            --start-time $START_TIME \
            --end-time $END_TIME \
            --period 300 \
            --statistics Average,Maximum \
            --query 'Datapoints[0].Average' --output text 2>/dev/null || echo "0")

          echo "CPU Utilization: ${CPU_METRICS}%"
          echo "Memory Utilization: ${MEMORY_METRICS}%"

          # Check for high resource usage
          if (( $(echo "$CPU_METRICS > 80" | bc -l) )); then
            echo "‚ö†Ô∏è High CPU utilization detected: ${CPU_METRICS}%"
            echo "cpu_alert=true" >> $GITHUB_ENV
          fi

          if (( $(echo "$MEMORY_METRICS > 80" | bc -l) )); then
            echo "‚ö†Ô∏è High memory utilization detected: ${MEMORY_METRICS}%"
            echo "memory_alert=true" >> $GITHUB_ENV
          fi

      - name: Check application metrics
        run: |
          # Check custom application metrics
          END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S)
          START_TIME=$(date -u -d '15 minutes ago' +%Y-%m-%dT%H:%M:%S)

          # Check error rate
          ERROR_COUNT=$(aws cloudwatch get-metric-statistics \
            --namespace Noah/ReadingAgent \
            --metric-name HTTP.Errors \
            --start-time $START_TIME \
            --end-time $END_TIME \
            --period 300 \
            --statistics Sum \
            --query 'Datapoints[0].Sum' --output text 2>/dev/null || echo "0")

          # Check request count
          REQUEST_COUNT=$(aws cloudwatch get-metric-statistics \
            --namespace Noah/ReadingAgent \
            --metric-name HTTP.Requests \
            --start-time $START_TIME \
            --end-time $END_TIME \
            --period 300 \
            --statistics Sum \
            --query 'Datapoints[0].Sum' --output text 2>/dev/null || echo "0")

          echo "Errors in last 15 minutes: $ERROR_COUNT"
          echo "Requests in last 15 minutes: $REQUEST_COUNT"

          # Calculate error rate
          if [[ "$REQUEST_COUNT" != "0" && "$REQUEST_COUNT" != "None" ]]; then
            ERROR_RATE=$(echo "scale=2; $ERROR_COUNT * 100 / $REQUEST_COUNT" | bc)
            echo "Error rate: ${ERROR_RATE}%"
            
            if (( $(echo "$ERROR_RATE > 5" | bc -l) )); then
              echo "‚ö†Ô∏è High error rate detected: ${ERROR_RATE}%"
              echo "error_rate_alert=true" >> $GITHUB_ENV
            fi
          fi

      - name: Create performance alert if needed
        if: env.cpu_alert == 'true' || env.memory_alert == 'true' || env.error_rate_alert == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const alerts = [];
            if (process.env.cpu_alert === 'true') alerts.push('High CPU Usage');
            if (process.env.memory_alert === 'true') alerts.push('High Memory Usage');
            if (process.env.error_rate_alert === 'true') alerts.push('High Error Rate');

            const title = `‚ö†Ô∏è Performance Alert: ${alerts.join(', ')}`;
            const body = `## Performance Alert

            **Alerts:** ${alerts.join(', ')}
            **Timestamp:** ${new Date().toISOString()}
            **Environment:** Production

            ### Metrics
            - CPU Utilization: Check CloudWatch for details
            - Memory Utilization: Check CloudWatch for details
            - Error Rate: Check application logs

            ### Recommended Actions
            1. Review CloudWatch metrics and logs
            2. Check for any recent deployments
            3. Monitor system performance
            4. Consider scaling if needed

            This alert was generated by automated monitoring.
            `;

            // Create issue for performance alert
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['alert', 'performance', 'production']
            });

            console.log(`Created performance alert: ${issue.data.html_url}`);

  # Database monitoring
  database-check:
    name: Database Monitoring
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check RDS metrics
        run: |
          # Get RDS instance identifier
          DB_INSTANCE=$(aws rds describe-db-instances --query 'DBInstances[?contains(DBInstanceIdentifier, `noah`)].DBInstanceIdentifier' --output text)

          if [[ -n "$DB_INSTANCE" && "$DB_INSTANCE" != "None" ]]; then
            echo "Checking database: $DB_INSTANCE"
            
            END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S)
            START_TIME=$(date -u -d '15 minutes ago' +%Y-%m-%dT%H:%M:%S)
            
            # Check CPU utilization
            DB_CPU=$(aws cloudwatch get-metric-statistics \
              --namespace AWS/RDS \
              --metric-name CPUUtilization \
              --dimensions Name=DBInstanceIdentifier,Value=$DB_INSTANCE \
              --start-time $START_TIME \
              --end-time $END_TIME \
              --period 300 \
              --statistics Average \
              --query 'Datapoints[0].Average' --output text 2>/dev/null || echo "0")
            
            # Check database connections
            DB_CONNECTIONS=$(aws cloudwatch get-metric-statistics \
              --namespace AWS/RDS \
              --metric-name DatabaseConnections \
              --dimensions Name=DBInstanceIdentifier,Value=$DB_INSTANCE \
              --start-time $START_TIME \
              --end-time $END_TIME \
              --period 300 \
              --statistics Average \
              --query 'Datapoints[0].Average' --output text 2>/dev/null || echo "0")
            
            echo "Database CPU: ${DB_CPU}%"
            echo "Database Connections: $DB_CONNECTIONS"
            
            # Check for high database usage
            if (( $(echo "$DB_CPU > 80" | bc -l) )); then
              echo "‚ö†Ô∏è High database CPU detected: ${DB_CPU}%"
              echo "db_cpu_alert=true" >> $GITHUB_ENV
            fi
            
            if (( $(echo "$DB_CONNECTIONS > 80" | bc -l) )); then
              echo "‚ö†Ô∏è High database connections detected: $DB_CONNECTIONS"
              echo "db_connections_alert=true" >> $GITHUB_ENV
            fi
          else
            echo "No RDS instance found"
          fi

      - name: Create database alert if needed
        if: env.db_cpu_alert == 'true' || env.db_connections_alert == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const alerts = [];
            if (process.env.db_cpu_alert === 'true') alerts.push('High Database CPU');
            if (process.env.db_connections_alert === 'true') alerts.push('High Database Connections');

            const title = `üóÑÔ∏è Database Alert: ${alerts.join(', ')}`;
            const body = `## Database Performance Alert

            **Alerts:** ${alerts.join(', ')}
            **Timestamp:** ${new Date().toISOString()}
            **Environment:** Production

            ### Recommended Actions
            1. Check RDS CloudWatch metrics
            2. Review slow query logs
            3. Check for long-running transactions
            4. Consider connection pooling optimization
            5. Monitor for deadlocks or blocking queries

            ### Escalation
            - [ ] Review database performance
            - [ ] Check application connection patterns
            - [ ] Consider database scaling if needed

            This alert was generated by automated monitoring.
            `;

            // Create issue for database alert
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['alert', 'database', 'production']
            });

            console.log(`Created database alert: ${issue.data.html_url}`);
